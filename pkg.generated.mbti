// Generated using `moon info`, DON'T EDIT IT
package "f4ah6o/http11"

// Values
pub fn encode_chunk(Array[Byte]) -> Array[Byte]

pub fn encode_chunks(Array[Array[Byte]]) -> Array[Byte]

pub fn encode_request(Request) -> Array[Byte]

pub fn encode_request_headers(Request) -> Array[Byte]

pub fn encode_response(Response) -> Array[Byte]

pub fn encode_response_headers(Response) -> Array[Byte]

pub fn parse_etag_list(String) -> Result[ETagList, ETagError]

pub fn percent_decode(String) -> Result[String, UriError]

pub fn percent_decode_bytes(String) -> Result[Array[Int], UriError]

pub fn percent_encode(String) -> String

pub fn percent_encode_path(String) -> String

pub fn percent_encode_query(String) -> String

pub fn rg_parse_u64(String) -> UInt64?

pub fn rg_u64_to_string(UInt64) -> String

// Errors

// Types and methods
pub(all) struct Accept {
  items : Array[MediaRange]
}
pub fn Accept::items(Self) -> Array[MediaRange]
pub fn Accept::parse(String) -> Result[Self, AcceptError]
pub fn Accept::to_string(Self) -> String
pub impl Eq for Accept

pub(all) struct AcceptCharset {
  items : Array[CharsetRange]
}
pub fn AcceptCharset::items(Self) -> Array[CharsetRange]
pub fn AcceptCharset::parse(String) -> Result[Self, AcceptError]
pub impl Eq for AcceptCharset

pub(all) struct AcceptEncoding {
  items : Array[EncodingRange]
}
pub fn AcceptEncoding::items(Self) -> Array[EncodingRange]
pub fn AcceptEncoding::parse(String) -> Result[Self, AcceptError]
pub impl Eq for AcceptEncoding

pub(all) enum AcceptError {
  Empty
  InvalidFormat
  InvalidMediaRange
  InvalidToken
  InvalidParameter
  InvalidQValue
  InvalidLanguageTag
}
pub impl Eq for AcceptError
pub impl Show for AcceptError

pub(all) struct AcceptLanguage {
  items : Array[LanguageRange]
}
pub fn AcceptLanguage::items(Self) -> Array[LanguageRange]
pub fn AcceptLanguage::parse(String) -> Result[Self, AcceptError]
pub impl Eq for AcceptLanguage

pub(all) struct AcceptRanges {
  units : Array[String]
}
pub fn AcceptRanges::accepts_bytes(Self) -> Bool
pub fn AcceptRanges::bytes() -> Self
pub fn AcceptRanges::is_none(Self) -> Bool
pub fn AcceptRanges::none() -> Self
pub fn AcceptRanges::parse(String) -> Result[Self, RangeError]
pub fn AcceptRanges::to_string(Self) -> String
pub fn AcceptRanges::units(Self) -> Array[String]
pub impl Eq for AcceptRanges

pub(all) struct Age {
  seconds : Int
}
pub fn Age::new(Int) -> Self
pub fn Age::parse(String) -> Result[Self, CacheError]
pub fn Age::seconds(Self) -> Int
pub fn Age::to_string(Self) -> String
pub impl Eq for Age

pub(all) enum AuthChallenge {
  Basic(WwwAuthenticate)
  Digest(DigestChallenge)
  Bearer(BearerChallenge)
}
pub fn AuthChallenge::parse(String) -> Result[Self, AuthError]
pub fn AuthChallenge::to_header_value(Self) -> String
pub fn AuthChallenge::to_string(Self) -> String
pub impl Eq for AuthChallenge

pub(all) enum AuthError {
  Empty
  InvalidFormat
  NotBasicScheme
  NotDigestScheme
  NotBearerScheme
  Base64DecodeError
  Utf8Error
  MissingColon
  InvalidParameter
  MissingParameter
  InvalidToken
}
pub impl Eq for AuthError
pub impl Show for AuthError

pub(all) enum Authorization {
  Basic(BasicAuth)
  Digest(DigestAuth)
  Bearer(BearerToken)
}
pub fn Authorization::parse(String) -> Result[Self, AuthError]
pub fn Authorization::to_header_value(Self) -> String
pub fn Authorization::to_string(Self) -> String
pub impl Eq for Authorization

pub(all) struct BasicAuth {
  username : String
  password : String
}
pub fn BasicAuth::new(String, String) -> Self
pub fn BasicAuth::parse(String) -> Result[Self, AuthError]
pub fn BasicAuth::password(Self) -> String
pub fn BasicAuth::to_header_value(Self) -> String
pub fn BasicAuth::to_string(Self) -> String
pub fn BasicAuth::username(Self) -> String
pub impl Eq for BasicAuth

pub(all) struct BearerChallenge {
  params : Array[(String, String)]
}
pub fn BearerChallenge::param(Self, String) -> String?
pub fn BearerChallenge::parse(String) -> Result[Self, AuthError]
pub fn BearerChallenge::to_header_value(Self) -> String
pub fn BearerChallenge::to_string(Self) -> String
pub impl Eq for BearerChallenge

pub(all) struct BearerToken {
  token : String
}
pub fn BearerToken::parse(String) -> Result[Self, AuthError]
pub fn BearerToken::to_header_value(Self) -> String
pub fn BearerToken::to_string(Self) -> String
pub fn BearerToken::token(Self) -> String
pub impl Eq for BearerToken

pub(all) struct CacheControl {
  max_age : Int?
  s_maxage : Int?
  max_stale : Int?
  min_fresh : Int?
  stale_while_revalidate : Int?
  stale_if_error : Int?
  no_cache : Bool
  no_store : Bool
  no_transform : Bool
  only_if_cached : Bool
  must_revalidate : Bool
  proxy_revalidate : Bool
  must_understand : Bool
  public : Bool
  private : Bool
  immutable : Bool
}
pub fn CacheControl::is_cacheable(Self) -> Bool
pub fn CacheControl::is_immutable(Self) -> Bool
pub fn CacheControl::is_must_revalidate(Self) -> Bool
pub fn CacheControl::is_must_understand(Self) -> Bool
pub fn CacheControl::is_no_cache(Self) -> Bool
pub fn CacheControl::is_no_store(Self) -> Bool
pub fn CacheControl::is_no_transform(Self) -> Bool
pub fn CacheControl::is_only_if_cached(Self) -> Bool
pub fn CacheControl::is_private(Self) -> Bool
pub fn CacheControl::is_proxy_revalidate(Self) -> Bool
pub fn CacheControl::is_public(Self) -> Bool
pub fn CacheControl::max_age(Self) -> Int?
pub fn CacheControl::max_stale(Self) -> Int?
pub fn CacheControl::min_fresh(Self) -> Int?
pub fn CacheControl::new() -> Self
pub fn CacheControl::parse(String) -> Result[Self, CacheError]
pub fn CacheControl::s_maxage(Self) -> Int?
pub fn CacheControl::stale_if_error(Self) -> Int?
pub fn CacheControl::stale_while_revalidate(Self) -> Int?
pub fn CacheControl::to_string(Self) -> String
pub fn CacheControl::with_immutable(Self) -> Self
pub fn CacheControl::with_max_age(Self, Int) -> Self
pub fn CacheControl::with_must_revalidate(Self) -> Self
pub fn CacheControl::with_no_cache(Self) -> Self
pub fn CacheControl::with_no_store(Self) -> Self
pub fn CacheControl::with_no_transform(Self) -> Self
pub fn CacheControl::with_only_if_cached(Self) -> Self
pub fn CacheControl::with_private(Self) -> Self
pub fn CacheControl::with_proxy_revalidate(Self) -> Self
pub fn CacheControl::with_public(Self) -> Self
pub fn CacheControl::with_s_maxage(Self, Int) -> Self
pub impl Eq for CacheControl

pub(all) enum CacheError {
  Empty
  InvalidFormat
  InvalidNumber
  InvalidDate
}
pub impl Eq for CacheError
pub impl Show for CacheError

pub(all) struct CharsetRange {
  charset : String
  q : QValue
}
pub fn CharsetRange::charset(Self) -> String
pub fn CharsetRange::qvalue(Self) -> QValue
pub fn CharsetRange::to_string(Self) -> String
pub impl Eq for CharsetRange

pub(all) enum ConditionalError {
  Empty
  InvalidFormat
  ETagError
  DateError
}
pub impl Eq for ConditionalError
pub impl Show for ConditionalError

pub(all) enum ContentCoding {
  Gzip
  Deflate
  Compress
  Identity
  Br
  Zstd
  Other(String)
}
pub fn ContentCoding::to_string(Self) -> String
pub impl Eq for ContentCoding
pub impl Show for ContentCoding

pub(all) struct ContentDigest {
  entries : Array[(String, DigestValue)]
}
pub fn ContentDigest::entries(Self) -> Array[(String, DigestValue)]
pub fn ContentDigest::get(Self, String) -> DigestValue?
pub fn ContentDigest::parse(String) -> Result[Self, DigestFieldsError]
pub fn ContentDigest::to_string(Self) -> String
pub impl Eq for ContentDigest

pub(all) struct ContentDisposition {
  disposition_type : DispositionType
  filename : String?
  filename_ext : String?
  name : String?
  parameters : Array[(String, String)]
}
pub fn ContentDisposition::disposition_type(Self) -> DispositionType
pub fn ContentDisposition::filename(Self) -> String?
pub fn ContentDisposition::filename_ascii(Self) -> String?
pub fn ContentDisposition::filename_ext(Self) -> String?
pub fn ContentDisposition::is_attachment(Self) -> Bool
pub fn ContentDisposition::is_form_data(Self) -> Bool
pub fn ContentDisposition::is_inline(Self) -> Bool
pub fn ContentDisposition::name(Self) -> String?
pub fn ContentDisposition::new(DispositionType) -> Self
pub fn ContentDisposition::parameter(Self, String) -> String?
pub fn ContentDisposition::parse(String) -> Result[Self, ContentDispositionError]
pub fn ContentDisposition::to_string(Self) -> String
pub fn ContentDisposition::with_filename(Self, String) -> Self
pub fn ContentDisposition::with_filename_ext(Self, String) -> Self
pub fn ContentDisposition::with_name(Self, String) -> Self
pub impl Eq for ContentDisposition

pub(all) enum ContentDispositionError {
  Empty
  InvalidFormat
  InvalidDispositionType
  InvalidParameter
  InvalidExtValue
}
pub impl Eq for ContentDispositionError
pub impl Show for ContentDispositionError

pub(all) struct ContentEncoding {
  encodings : Array[ContentCoding]
}
pub fn ContentEncoding::encodings(Self) -> Array[ContentCoding]
pub fn ContentEncoding::has_br(Self) -> Bool
pub fn ContentEncoding::has_compress(Self) -> Bool
pub fn ContentEncoding::has_deflate(Self) -> Bool
pub fn ContentEncoding::has_gzip(Self) -> Bool
pub fn ContentEncoding::has_identity(Self) -> Bool
pub fn ContentEncoding::has_zstd(Self) -> Bool
pub fn ContentEncoding::parse(String) -> Result[Self, ContentEncodingError]
pub fn ContentEncoding::to_string(Self) -> String
pub impl Eq for ContentEncoding

pub(all) enum ContentEncodingError {
  Empty
  InvalidFormat
  InvalidEncoding
}
pub impl Eq for ContentEncodingError
pub impl Show for ContentEncodingError

pub(all) struct ContentLanguage {
  tags : Array[String]
}
pub fn ContentLanguage::parse(String) -> Result[Self, ContentLanguageError]
pub fn ContentLanguage::tags(Self) -> Array[String]
pub fn ContentLanguage::to_string(Self) -> String
pub impl Eq for ContentLanguage

pub(all) enum ContentLanguageError {
  Empty
  InvalidFormat
  InvalidLanguageTag
}
pub impl Eq for ContentLanguageError
pub impl Show for ContentLanguageError

pub(all) struct ContentLocation {
  uri : Uri
}
pub fn ContentLocation::parse(String) -> Result[Self, ContentLocationError]
pub fn ContentLocation::to_string(Self) -> String
pub fn ContentLocation::uri(Self) -> Uri
pub impl Eq for ContentLocation

pub(all) enum ContentLocationError {
  Empty
  InvalidUri
}
pub impl Eq for ContentLocationError
pub impl Show for ContentLocationError

pub(all) struct ContentRange {
  unit : String
  start : UInt64?
  end : UInt64?
  complete_length : UInt64?
}
pub fn ContentRange::complete_length(Self) -> UInt64?
pub fn ContentRange::end(Self) -> UInt64?
pub fn ContentRange::is_unsatisfied(Self) -> Bool
pub fn ContentRange::length(Self) -> UInt64?
pub fn ContentRange::new_bytes(UInt64, UInt64, UInt64?) -> Self
pub fn ContentRange::parse(String) -> Result[Self, RangeError]
pub fn ContentRange::start(Self) -> UInt64?
pub fn ContentRange::to_string(Self) -> String
pub fn ContentRange::unit(Self) -> String
pub fn ContentRange::unsatisfied(String, UInt64) -> Self
pub impl Eq for ContentRange

pub(all) struct ContentType {
  media_type : String
  subtype : String
  parameters : Array[(String, String)]
}
pub fn ContentType::boundary(Self) -> String?
pub fn ContentType::charset(Self) -> String?
pub fn ContentType::is_form_data(Self) -> Bool
pub fn ContentType::is_form_urlencoded(Self) -> Bool
pub fn ContentType::is_json(Self) -> Bool
pub fn ContentType::is_multipart(Self) -> Bool
pub fn ContentType::is_text(Self) -> Bool
pub fn ContentType::media_type(Self) -> String
pub fn ContentType::mime_type(Self) -> String
pub fn ContentType::new(String, String) -> Self
pub fn ContentType::parameter(Self, String) -> String?
pub fn ContentType::parameters(Self) -> Array[(String, String)]
pub fn ContentType::parse(String) -> Result[Self, ContentTypeError]
pub fn ContentType::subtype(Self) -> String
pub fn ContentType::to_string(Self) -> String
pub fn ContentType::with_parameter(Self, String, String) -> Self
pub impl Eq for ContentType

pub(all) enum ContentTypeError {
  Empty
  InvalidMediaType
  InvalidParameter
  UnterminatedQuote
}
pub impl Eq for ContentTypeError
pub impl Show for ContentTypeError

pub(all) struct Cookie {
  name : String
  value : String
}
pub fn Cookie::name(Self) -> String
pub fn Cookie::new(String, String) -> Result[Self, CookieError]
pub fn Cookie::parse(String) -> Result[Array[Self], CookieError]
pub fn Cookie::to_string(Self) -> String
pub fn Cookie::value(Self) -> String
pub impl Eq for Cookie

pub(all) enum CookieError {
  Empty
  InvalidFormat
  InvalidName
  InvalidValue
  InvalidAttribute
  InvalidExpires
  InvalidMaxAge
  InvalidSameSite
}
pub impl Eq for CookieError
pub impl Show for CookieError

pub(all) enum DateError {
  Empty
  InvalidFormat
  InvalidDayName
  InvalidDay
  InvalidMonth
  InvalidYear
  InvalidHour
  InvalidMinute
  InvalidSecond
  NotGmt
}
pub impl Eq for DateError
pub impl Show for DateError

pub(all) enum DayOfWeek {
  Sunday
  Monday
  Tuesday
  Wednesday
  Thursday
  Friday
  Saturday
}
pub impl Eq for DayOfWeek
pub impl Show for DayOfWeek

pub(all) enum DecodeState {
  Start
  StartLine
  Headers
  Body(Int)
  Complete
}
pub impl Eq for DecodeState
pub impl Show for DecodeState

pub(all) struct DecoderLimits {
  max_buffer_size : Int
  max_headers_count : Int
  max_header_line_size : Int
  max_body_size : Int
}
pub fn DecoderLimits::default() -> Self
pub fn DecoderLimits::unlimited() -> Self
pub impl Eq for DecoderLimits
pub impl Show for DecoderLimits

pub(all) struct DigestAuth {
  params : Array[(String, String)]
}
pub fn DigestAuth::nonce(Self) -> String?
pub fn DigestAuth::param(Self, String) -> String?
pub fn DigestAuth::parse(String) -> Result[Self, AuthError]
pub fn DigestAuth::realm(Self) -> String?
pub fn DigestAuth::response(Self) -> String?
pub fn DigestAuth::to_header_value(Self) -> String
pub fn DigestAuth::to_string(Self) -> String
pub fn DigestAuth::uri(Self) -> String?
pub fn DigestAuth::username(Self) -> String?
pub impl Eq for DigestAuth

pub(all) struct DigestChallenge {
  params : Array[(String, String)]
}
pub fn DigestChallenge::nonce(Self) -> String?
pub fn DigestChallenge::param(Self, String) -> String?
pub fn DigestChallenge::parse(String) -> Result[Self, AuthError]
pub fn DigestChallenge::realm(Self) -> String?
pub fn DigestChallenge::to_header_value(Self) -> String
pub fn DigestChallenge::to_string(Self) -> String
pub impl Eq for DigestChallenge

pub(all) struct DigestEntry {
  algorithm : String
  value : DigestValue
}
pub fn DigestEntry::algorithm(Self) -> String
pub fn DigestEntry::new(String, DigestValue) -> Self
pub fn DigestEntry::to_string(Self) -> String
pub fn DigestEntry::value(Self) -> DigestValue
pub impl Eq for DigestEntry

pub(all) enum DigestFieldsError {
  Empty
  InvalidFormat
  InvalidAlgorithm
  InvalidByteSequence
  InvalidBase64
  InvalidPreference
}
pub impl Eq for DigestFieldsError
pub impl Show for DigestFieldsError

pub(all) struct DigestPreference {
  algorithm : String
  weight : Int
}
pub fn DigestPreference::algorithm(Self) -> String
pub fn DigestPreference::new(String, Int) -> Self
pub fn DigestPreference::to_string(Self) -> String
pub fn DigestPreference::weight(Self) -> Int
pub impl Eq for DigestPreference

pub(all) struct DigestValue {
  bytes : Array[Byte]
}
pub fn DigestValue::bytes(Self) -> Array[Byte]
pub fn DigestValue::new(Array[Byte]) -> Self
pub fn DigestValue::to_string(Self) -> String
pub impl Eq for DigestValue

pub(all) enum DispositionType {
  Inline
  Attachment
  FormData
}
pub fn DispositionType::to_string(Self) -> String
pub impl Eq for DispositionType

pub(all) enum ETagError {
  Empty
  InvalidFormat
  MissingQuote
  InvalidCharacter
}
pub impl Eq for ETagError
pub impl Show for ETagError

pub(all) enum ETagList {
  Any
  Tags(Array[EntityTag])
}
pub fn ETagList::contains_strong(Self, EntityTag) -> Bool
pub fn ETagList::contains_weak(Self, EntityTag) -> Bool
pub fn ETagList::is_any(Self) -> Bool
pub fn ETagList::to_string(Self) -> String
pub impl Eq for ETagList
pub impl Show for ETagList

pub(all) struct EncodingRange {
  coding : String
  q : QValue
}
pub fn EncodingRange::coding(Self) -> String
pub fn EncodingRange::qvalue(Self) -> QValue
pub fn EncodingRange::to_string(Self) -> String
pub impl Eq for EncodingRange

pub(all) struct EntityTag {
  weak : Bool
  tag : String
}
pub fn EntityTag::is_strong(Self) -> Bool
pub fn EntityTag::is_weak(Self) -> Bool
pub fn EntityTag::parse(String) -> Result[Self, ETagError]
pub fn EntityTag::strong(String) -> Result[Self, ETagError]
pub fn EntityTag::strong_compare(Self, Self) -> Bool
pub fn EntityTag::tag(Self) -> String
pub fn EntityTag::to_string(Self) -> String
pub fn EntityTag::weak(String) -> Result[Self, ETagError]
pub fn EntityTag::weak_compare(Self, Self) -> Bool
pub impl Eq for EntityTag
pub impl Show for EntityTag

pub(all) struct Expect {
  items : Array[Expectation]
}
pub fn Expect::has_100_continue(Self) -> Bool
pub fn Expect::items(Self) -> Array[Expectation]
pub fn Expect::parse(String) -> Result[Self, ExpectError]
pub fn Expect::to_string(Self) -> String
pub impl Eq for Expect
pub impl Show for Expect

pub(all) enum ExpectError {
  Empty
  InvalidFormat
  InvalidToken
  InvalidValue
}
pub impl Eq for ExpectError
pub impl Show for ExpectError

pub(all) struct Expectation {
  token : String
  value : String?
}
pub fn Expectation::is_100_continue(Self) -> Bool
pub fn Expectation::to_string(Self) -> String
pub fn Expectation::token(Self) -> String
pub fn Expectation::value(Self) -> String?
pub impl Eq for Expectation
pub impl Show for Expectation

pub(all) struct Expires {
  date : HttpDate
}
pub fn Expires::date(Self) -> HttpDate
pub fn Expires::new(HttpDate) -> Self
pub fn Expires::parse(String) -> Result[Self, CacheError]
pub fn Expires::to_string(Self) -> String
pub impl Eq for Expires

pub(all) struct Host {
  host : String
  port : Int?
}
pub fn Host::host(Self) -> String
pub fn Host::is_ipv6(Self) -> Bool
pub fn Host::parse(String) -> Result[Self, HostError]
pub fn Host::port(Self) -> Int?
pub fn Host::to_string(Self) -> String
pub impl Eq for Host
pub impl Show for Host

pub(all) enum HostError {
  Empty
  InvalidFormat
  InvalidHost
  InvalidPort
}
pub impl Eq for HostError
pub impl Show for HostError

pub(all) struct HttpDate {
  day_of_week : DayOfWeek
  day : Int
  month : Int
  year : Int
  hour : Int
  minute : Int
  second : Int
}
pub fn HttpDate::day(Self) -> Int
pub fn HttpDate::day_of_week(Self) -> DayOfWeek
pub fn HttpDate::hour(Self) -> Int
pub fn HttpDate::minute(Self) -> Int
pub fn HttpDate::month(Self) -> Int
pub fn HttpDate::new(DayOfWeek, Int, Int, Int, Int, Int, Int) -> Result[Self, DateError]
pub fn HttpDate::parse(String) -> Result[Self, DateError]
pub fn HttpDate::second(Self) -> Int
pub fn HttpDate::to_string(Self) -> String
pub fn HttpDate::year(Self) -> Int
pub impl Eq for HttpDate
pub impl Show for HttpDate

pub(all) enum HttpError {
  InvalidData(String)
  BufferOverflow(Int, Int)
  TooManyHeaders(Int, Int)
  HeaderLineTooLong(Int, Int)
  BodyTooLarge(Int, Int)
  UnexpectedEof
  InvalidHeaderValue
  InvalidStatusCode
  InvalidChunkSize
}
pub impl Eq for HttpError
pub impl Show for HttpError

pub(all) struct IfMatch {
  etags : ETagList
}
pub fn IfMatch::etags(Self) -> ETagList
pub fn IfMatch::is_any(Self) -> Bool
pub fn IfMatch::matches(Self, EntityTag) -> Bool
pub fn IfMatch::parse(String) -> Result[Self, ConditionalError]
pub fn IfMatch::to_string(Self) -> String
pub impl Eq for IfMatch

pub(all) struct IfModifiedSince {
  date : HttpDate
}
pub fn IfModifiedSince::date(Self) -> HttpDate
pub fn IfModifiedSince::parse(String) -> Result[Self, ConditionalError]
pub fn IfModifiedSince::to_string(Self) -> String
pub impl Eq for IfModifiedSince

pub(all) struct IfNoneMatch {
  etags : ETagList
}
pub fn IfNoneMatch::etags(Self) -> ETagList
pub fn IfNoneMatch::is_any(Self) -> Bool
pub fn IfNoneMatch::matches(Self, EntityTag) -> Bool
pub fn IfNoneMatch::parse(String) -> Result[Self, ConditionalError]
pub fn IfNoneMatch::to_string(Self) -> String
pub impl Eq for IfNoneMatch

pub(all) enum IfRange {
  ETag(EntityTag)
  Date(HttpDate)
}
pub fn IfRange::date(Self) -> HttpDate?
pub fn IfRange::etag(Self) -> EntityTag?
pub fn IfRange::is_date(Self) -> Bool
pub fn IfRange::is_etag(Self) -> Bool
pub fn IfRange::parse(String) -> Result[Self, ConditionalError]
pub fn IfRange::to_string(Self) -> String
pub impl Eq for IfRange

pub(all) struct IfUnmodifiedSince {
  date : HttpDate
}
pub fn IfUnmodifiedSince::date(Self) -> HttpDate
pub fn IfUnmodifiedSince::parse(String) -> Result[Self, ConditionalError]
pub fn IfUnmodifiedSince::to_string(Self) -> String
pub impl Eq for IfUnmodifiedSince

pub(all) struct LanguageRange {
  language : String
  q : QValue
}
pub fn LanguageRange::language(Self) -> String
pub fn LanguageRange::qvalue(Self) -> QValue
pub fn LanguageRange::to_string(Self) -> String
pub impl Eq for LanguageRange

pub(all) struct MediaRange {
  media_type : String
  subtype : String
  parameters : Array[(String, String)]
  q : QValue
}
pub fn MediaRange::media_type(Self) -> String
pub fn MediaRange::parameters(Self) -> Array[(String, String)]
pub fn MediaRange::qvalue(Self) -> QValue
pub fn MediaRange::subtype(Self) -> String
pub fn MediaRange::to_string(Self) -> String
pub impl Eq for MediaRange

pub(all) struct Protocol {
  name : String
  version : String?
}
pub fn Protocol::name(Self) -> String
pub fn Protocol::to_string(Self) -> String
pub fn Protocol::version(Self) -> String?
pub impl Eq for Protocol
pub impl Show for Protocol

pub(all) struct ProxyAuthenticate {
  challenge : AuthChallenge
}
pub fn ProxyAuthenticate::challenge(Self) -> AuthChallenge
pub fn ProxyAuthenticate::parse(String) -> Result[Self, AuthError]
pub fn ProxyAuthenticate::to_header_value(Self) -> String
pub fn ProxyAuthenticate::to_string(Self) -> String
pub impl Eq for ProxyAuthenticate

pub(all) struct ProxyAuthorization {
  auth : Authorization
}
pub fn ProxyAuthorization::authorization(Self) -> Authorization
pub fn ProxyAuthorization::parse(String) -> Result[Self, AuthError]
pub fn ProxyAuthorization::to_header_value(Self) -> String
pub fn ProxyAuthorization::to_string(Self) -> String
pub impl Eq for ProxyAuthorization

pub(all) struct QValue {
  value : Int
}
pub fn QValue::parse(String) -> Result[Self, AcceptError]
pub fn QValue::to_string(Self) -> String
pub fn QValue::value(Self) -> Int
pub impl Eq for QValue

pub(all) struct Range {
  unit : String
  ranges : Array[RangeSpec]
}
pub fn Range::first(Self) -> RangeSpec?
pub fn Range::is_bytes(Self) -> Bool
pub fn Range::parse(String) -> Result[Self, RangeError]
pub fn Range::ranges(Self) -> Array[RangeSpec]
pub fn Range::to_string(Self) -> String
pub fn Range::unit(Self) -> String
pub impl Eq for Range

pub(all) enum RangeError {
  Empty
  InvalidFormat
  InvalidUnit
  InvalidRange
  InvalidBounds
}
pub impl Eq for RangeError
pub impl Show for RangeError

pub(all) enum RangeSpec {
  Range(UInt64, UInt64)
  FromStart(UInt64)
  Suffix(UInt64)
}
pub fn RangeSpec::to_bounds(Self, UInt64) -> (UInt64, UInt64)?
pub fn RangeSpec::to_string(Self) -> String
pub impl Eq for RangeSpec

pub(all) struct ReprDigest {
  entries : Array[(String, DigestValue)]
}
pub fn ReprDigest::entries(Self) -> Array[(String, DigestValue)]
pub fn ReprDigest::get(Self, String) -> DigestValue?
pub fn ReprDigest::parse(String) -> Result[Self, DigestFieldsError]
pub fn ReprDigest::to_string(Self) -> String
pub impl Eq for ReprDigest

pub(all) struct Request {
  http_method : String
  uri : String
  version : String
  headers : Array[(String, String)]
  body : Array[Byte]
}
pub fn Request::body(Self, Array[Byte]) -> Self
pub fn Request::content_length(Self) -> Int?
pub fn Request::get_header(Self, String) -> String?
pub fn Request::has_header(Self, String) -> Bool
pub fn Request::header(Self, String, String) -> Self
pub fn Request::is_chunked(Self) -> Bool
pub fn Request::is_keep_alive(Self) -> Bool
pub fn Request::method(Self) -> String
pub fn Request::new(String, String) -> Self
pub fn Request::with_version(String, String, String) -> Self
pub impl Eq for Request
pub impl Show for Request

pub(all) struct RequestDecoder {
  mut buf : Array[Byte]
  mut state : DecodeState
  mut parsed_method : String?
  mut parsed_uri : String?
  mut parsed_version : String?
  mut headers : Array[(String, String)]
  mut body_buf : Array[Byte]
  mut content_length : Int?
  limits : DecoderLimits
}
pub fn RequestDecoder::decode(Self) -> Result[Request?, HttpError]
pub fn RequestDecoder::feed(Self, Array[Byte]) -> Result[Unit, HttpError]
pub fn RequestDecoder::new() -> Self
pub fn RequestDecoder::remaining(Self) -> Array[Byte]
pub fn RequestDecoder::reset(Self) -> Unit
pub fn RequestDecoder::with_limits(DecoderLimits) -> Self
pub impl Show for RequestDecoder

pub(all) struct Response {
  version : String
  status_code : Int
  reason_phrase : String
  headers : Array[(String, String)]
  body : Array[Byte]
}
pub fn Response::body(Self, Array[Byte]) -> Self
pub fn Response::content_length(Self) -> Int?
pub fn Response::get_header(Self, String) -> String?
pub fn Response::has_header(Self, String) -> Bool
pub fn Response::header(Self, String, String) -> Self
pub fn Response::is_chunked(Self) -> Bool
pub fn Response::is_client_error(Self) -> Bool
pub fn Response::is_keep_alive(Self) -> Bool
pub fn Response::is_redirect(Self) -> Bool
pub fn Response::is_server_error(Self) -> Bool
pub fn Response::is_success(Self) -> Bool
pub fn Response::new(Int, String) -> Self
pub fn Response::with_version(String, Int, String) -> Self
pub impl Eq for Response
pub impl Show for Response

pub(all) struct ResponseDecoder {
  mut buf : Array[Byte]
  mut state : DecodeState
  mut parsed_version : String?
  mut parsed_status_code : Int?
  mut parsed_reason : String?
  mut headers : Array[(String, String)]
  mut body_buf : Array[Byte]
  mut content_length : Int?
  limits : DecoderLimits
}
pub fn ResponseDecoder::decode(Self) -> Result[Response?, HttpError]
pub fn ResponseDecoder::feed(Self, Array[Byte]) -> Result[Unit, HttpError]
pub fn ResponseDecoder::new() -> Self
pub fn ResponseDecoder::remaining(Self) -> Array[Byte]
pub fn ResponseDecoder::reset(Self) -> Unit
pub fn ResponseDecoder::with_limits(DecoderLimits) -> Self
pub impl Show for ResponseDecoder

pub(all) enum SameSite {
  Strict
  Lax
  SameSiteNone
}
pub fn SameSite::to_string(Self) -> String
pub impl Eq for SameSite

pub(all) struct SetCookie {
  name : String
  value : String
  expires : HttpDate?
  max_age : Int?
  domain : String?
  path : String?
  secure : Bool
  http_only : Bool
  same_site : SameSite?
}
pub fn SetCookie::domain(Self) -> String?
pub fn SetCookie::expires(Self) -> HttpDate?
pub fn SetCookie::http_only(Self) -> Bool
pub fn SetCookie::max_age(Self) -> Int?
pub fn SetCookie::name(Self) -> String
pub fn SetCookie::new(String, String) -> Result[Self, CookieError]
pub fn SetCookie::parse(String) -> Result[Self, CookieError]
pub fn SetCookie::path(Self) -> String?
pub fn SetCookie::same_site(Self) -> SameSite?
pub fn SetCookie::secure(Self) -> Bool
pub fn SetCookie::to_string(Self) -> String
pub fn SetCookie::value(Self) -> String
pub fn SetCookie::with_domain(Self, String) -> Self
pub fn SetCookie::with_expires(Self, HttpDate) -> Self
pub fn SetCookie::with_http_only(Self, Bool) -> Self
pub fn SetCookie::with_max_age(Self, Int) -> Self
pub fn SetCookie::with_path(Self, String) -> Self
pub fn SetCookie::with_same_site(Self, SameSite) -> Self
pub fn SetCookie::with_secure(Self, Bool) -> Self
pub impl Eq for SetCookie

pub(all) struct Trailer {
  fields : Array[String]
}
pub fn Trailer::fields(Self) -> Array[String]
pub fn Trailer::parse(String) -> Result[Self, TrailerError]
pub fn Trailer::to_string(Self) -> String
pub impl Eq for Trailer
pub impl Show for Trailer

pub(all) enum TrailerError {
  Empty
  InvalidFormat
  InvalidFieldName
}
pub impl Eq for TrailerError
pub impl Show for TrailerError

pub(all) struct Upgrade {
  protocols : Array[Protocol]
}
pub fn Upgrade::has_protocol(Self, String) -> Bool
pub fn Upgrade::parse(String) -> Result[Self, UpgradeError]
pub fn Upgrade::protocols(Self) -> Array[Protocol]
pub fn Upgrade::to_string(Self) -> String
pub impl Eq for Upgrade
pub impl Show for Upgrade

pub(all) enum UpgradeError {
  Empty
  InvalidFormat
  InvalidProtocol
  InvalidVersion
}
pub impl Eq for UpgradeError
pub impl Show for UpgradeError

pub(all) struct Uri {
  source : String
  scheme_end : Int?
  authority_start : Int?
  authority_end : Int?
  host_end : Int?
  port : Int?
  path_start : Int
  path_end : Int
  query_start : Int?
  query_end : Int?
  fragment_start : Int?
}
pub fn Uri::as_str(Self) -> String
pub fn Uri::authority(Self) -> String?
pub fn Uri::fragment(Self) -> String?
pub fn Uri::host(Self) -> String?
pub fn Uri::is_absolute(Self) -> Bool
pub fn Uri::is_relative(Self) -> Bool
pub fn Uri::origin_form(Self) -> String
pub fn Uri::parse(String) -> Result[Self, UriError]
pub fn Uri::path(Self) -> String
pub fn Uri::port(Self) -> Int?
pub fn Uri::query(Self) -> String?
pub fn Uri::scheme(Self) -> String?
pub fn Uri::to_string(Self) -> String
pub impl Eq for Uri
pub impl Show for Uri

pub(all) enum UriError {
  Empty
  InvalidPercentEncoding
  InvalidPort
  InvalidCharacter
  InvalidScheme
  InvalidHost
  InvalidUtf8
}
pub impl Eq for UriError
pub impl Show for UriError

pub(all) struct Vary {
  any : Bool
  fields : Array[String]
}
pub fn Vary::fields(Self) -> Array[String]
pub fn Vary::is_any(Self) -> Bool
pub fn Vary::parse(String) -> Result[Self, VaryError]
pub fn Vary::to_string(Self) -> String
pub impl Eq for Vary
pub impl Show for Vary

pub(all) enum VaryError {
  Empty
  InvalidFormat
  InvalidFieldName
}
pub impl Eq for VaryError
pub impl Show for VaryError

pub(all) struct WantContentDigest {
  preferences : Array[DigestPreference]
}
pub fn WantContentDigest::get(Self, String) -> Int?
pub fn WantContentDigest::parse(String) -> Result[Self, DigestFieldsError]
pub fn WantContentDigest::preferences(Self) -> Array[DigestPreference]
pub fn WantContentDigest::to_string(Self) -> String
pub impl Eq for WantContentDigest

pub(all) struct WantReprDigest {
  preferences : Array[DigestPreference]
}
pub fn WantReprDigest::get(Self, String) -> Int?
pub fn WantReprDigest::parse(String) -> Result[Self, DigestFieldsError]
pub fn WantReprDigest::preferences(Self) -> Array[DigestPreference]
pub fn WantReprDigest::to_string(Self) -> String
pub impl Eq for WantReprDigest

pub(all) struct WwwAuthenticate {
  realm : String
  charset : String?
}
pub fn WwwAuthenticate::basic(String) -> Self
pub fn WwwAuthenticate::charset(Self) -> String?
pub fn WwwAuthenticate::parse(String) -> Result[Self, AuthError]
pub fn WwwAuthenticate::realm(Self) -> String
pub fn WwwAuthenticate::to_header_value(Self) -> String
pub fn WwwAuthenticate::to_string(Self) -> String
pub fn WwwAuthenticate::with_charset(Self, String) -> Self
pub impl Eq for WwwAuthenticate

// Type aliases

// Traits

